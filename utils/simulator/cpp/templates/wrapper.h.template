#pragma once

#include <cstdint>
#include <memory>
#include <string>
#include "rust/cxx.h"

// Forward declarations
class VSvarogSoC_{{CONFIG_ID}};
class VerilatedVcdC;
class VerilatedContext;

namespace svarog {
namespace {{CONFIG_NAMESPACE}} {

// Verilator model wrapper providing type-safe access to the DUT
class VerilatorModel {
public:
    VerilatorModel();
    ~VerilatorModel();

    // VCD tracing
    void open_vcd(rust::Str path);
    void dump_vcd(uint64_t timestamp);
    void close_vcd();

    // Simulation control
    void eval();
    void final_eval();

    // Clock and reset
    uint8_t get_clock() const;
    void set_clock(uint8_t value);
    uint8_t get_reset() const;
    void set_reset(uint8_t value);

    // Timer clock (tied to main clock for simulation)
    void set_timer_clock(uint8_t value);

    // Debug hart interface - ID routing
    // NOTE: These signals only exist if built with --simulator-debug-iface=true
    uint8_t get_debug_hart_in_id_valid() const;
    void set_debug_hart_in_id_valid(uint8_t value);
    uint8_t get_debug_hart_in_id_bits() const;
    void set_debug_hart_in_id_bits(uint8_t value);

    // Debug hart interface - Halt control
    uint8_t get_debug_hart_in_bits_halt_valid() const;
    void set_debug_hart_in_bits_halt_valid(uint8_t value);
    uint8_t get_debug_hart_in_bits_halt_bits() const;
    void set_debug_hart_in_bits_halt_bits(uint8_t value);

    // Debug hart interface - Breakpoint
    uint8_t get_debug_hart_in_bits_breakpoint_valid() const;
    void set_debug_hart_in_bits_breakpoint_valid(uint8_t value);
    uint32_t get_debug_hart_in_bits_breakpoint_bits_pc() const;
    void set_debug_hart_in_bits_breakpoint_bits_pc(uint32_t value);

    // Debug hart interface - Watchpoint
    uint8_t get_debug_hart_in_bits_watchpoint_valid() const;
    void set_debug_hart_in_bits_watchpoint_valid(uint8_t value);
    uint32_t get_debug_hart_in_bits_watchpoint_bits_addr() const;
    void set_debug_hart_in_bits_watchpoint_bits_addr(uint32_t value);

    // Debug hart interface - Set PC
    uint8_t get_debug_hart_in_bits_setPC_valid() const;
    void set_debug_hart_in_bits_setPC_valid(uint8_t value);
    uint32_t get_debug_hart_in_bits_setPC_bits_pc() const;
    void set_debug_hart_in_bits_setPC_bits_pc(uint32_t value);

    // Debug hart interface - Register access
    uint8_t get_debug_hart_in_bits_register_valid() const;
    void set_debug_hart_in_bits_register_valid(uint8_t value);
    uint8_t get_debug_hart_in_bits_register_bits_reg() const;
    void set_debug_hart_in_bits_register_bits_reg(uint8_t value);
    uint8_t get_debug_hart_in_bits_register_bits_write() const;
    void set_debug_hart_in_bits_register_bits_write(uint8_t value);
    uint32_t get_debug_hart_in_bits_register_bits_data() const;
    void set_debug_hart_in_bits_register_bits_data(uint32_t value);

    // Debug memory interface - Request
    uint8_t get_debug_mem_in_valid() const;
    void set_debug_mem_in_valid(uint8_t value);
    uint8_t get_debug_mem_in_ready() const;
    uint32_t get_debug_mem_in_bits_addr() const;
    void set_debug_mem_in_bits_addr(uint32_t value);
    uint8_t get_debug_mem_in_bits_write() const;
    void set_debug_mem_in_bits_write(uint8_t value);
    uint32_t get_debug_mem_in_bits_data() const;
    void set_debug_mem_in_bits_data(uint32_t value);
    uint8_t get_debug_mem_in_bits_reqWidth() const;
    void set_debug_mem_in_bits_reqWidth(uint8_t value);
    uint8_t get_debug_mem_in_bits_instr() const;
    void set_debug_mem_in_bits_instr(uint8_t value);

    // Debug memory interface - Response
    uint8_t get_debug_mem_res_ready() const;
    void set_debug_mem_res_ready(uint8_t value);
    uint8_t get_debug_mem_res_valid() const;
    uint32_t get_debug_mem_res_bits() const;

    // Debug register interface - Response
    uint8_t get_debug_reg_res_ready() const;
    void set_debug_reg_res_ready(uint8_t value);
    uint8_t get_debug_reg_res_valid() const;
    uint32_t get_debug_reg_res_bits() const;

    // Debug status
    uint8_t get_debug_halted() const;

{{UART_ACCESSORS_HEADER}}
private:
    std::unique_ptr<VerilatedContext> context_;
    std::unique_ptr<VSvarogSoC_{{CONFIG_ID}}> model_;
    std::unique_ptr<VerilatedVcdC> vcd_;
    bool traced_ = false;
};

// Factory function for Rust
std::unique_ptr<VerilatorModel> create_verilator_model();

} // namespace {{CONFIG_NAMESPACE}}
} // namespace svarog
