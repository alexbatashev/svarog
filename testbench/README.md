# RISC-V CPU Testing Harness

This directory contains a Verilator-based testing harness for the Svarog RISC-V CPU. The design allows you to **generate Verilog once** and then **load different programs dynamically** from the testbench, making it ideal for running many test programs and cross-validating with Spike.

## Architecture

The testing harness consists of:

1. **LoadableInstructionRom**: Instruction ROM with a write port that can be controlled from the testbench
2. **VerilatorSoC**: SoC wrapper that exposes ROM and RAM write ports
3. **VerilatorTop**: Top-level module with all necessary test hooks
4. **Rust testbench**: Uses the `marlin` crate to interface with Verilator

## Building

The Verilog is automatically generated during the Rust build process:

```bash
# Generate Verilog and build testbench
cargo build

# Or manually generate Verilog
mill svarog.runMain svarog.GenerateVerilatorTop
```

The generated Verilog will be in `testbench/target/VerilatorTop.sv`.

## Configuration Options

You can customize the generated design with command-line arguments:

```bash
mill svarog.runMain svarog.GenerateVerilatorTop \
  --xlen=32 \
  --rom-size-kb=16 \
  --ram-size-kb=16 \
  --clock-hz=50000000 \
  --baud=115200 \
  --target-dir=testbench/target
```

## Loading Programs

Programs are loaded from the `.vh` images generated by riscv-tests. While `boot_hold` is asserted the testbench writes bytes into both the instruction ROM and the data RAM using the exposed write ports, guaranteeing that read-only text and mutable data share the same address space as Spike.

```rust
let image = testbench::load_vh_image("tests/rv32ui-p-add.vh")?;
testbench::load_program(&mut dut, &image);
```

## Running Tests

The test harness automatically runs all 42 rv32ui compliance tests and cross-validates against Spike:

```bash
# Run all 42 RISC-V compliance tests
cargo test --test integration

# Run a specific test
cargo test --test integration -- VerilatorTop::rv32ui-p-add

# Run with detailed output
cargo test --test integration -- --nocapture

# List all available tests
cargo test --test integration -- --list

# Run tests sequentially (useful for debugging)
cargo test --test integration -- --test-threads=1
```

All 42 tests currently pass, validating:
- Arithmetic: add, addi, sub
- Logical: and, andi, or, ori, xor, xori
- Shifts: sll, slli, srl, srli, sra, srai
- Comparisons: slt, slti, sltu, sltiu
- Branches: beq, bne, blt, bge, bltu, bgeu
- Jumps: jal, jalr
- Loads: lb, lh, lw, lbu, lhu
- Stores: sb, sh, sw
- Upper immediate: lui, auipc
- Memory ordering: fence_i

## Register File Access

After a test completes you can inspect the architectural state directly from Verilator:

- `boot_hold`: Assert to freeze the pipeline while reprogramming instruction memory.
- `regfile_read_en`: Enable readback path.
- `regfile_read_addr`: Select register (0-31).
- `regfile_read_data`: Sampled value of the selected register.

Example snippet:

```rust
fn capture_registers(dut: &mut VerilatorTop) -> [u32; 32] {
    let mut regs = [0u32; 32];
    dut.regfile_read_en = 1;
    for idx in 0..32 {
        dut.regfile_read_addr = idx;
        dut.eval(); // propagate new address
        regs[idx as usize] = dut.regfile_read_data;
    }
    dut.regfile_read_en = 0;
    regs
}
```

## Cross-Validation with Spike

✅ **Fully Implemented**: The test harness automatically:

1. Downloads and builds the official RISC-V test suite (rv32ui)
2. Runs each test on the Verilator model
3. Runs the same test on Spike (RISC-V ISA simulator)
4. Compares all 32 register values between implementations
5. Reports any mismatches with detailed hex values

The implementation uses:
- **libtest-mimic**: Each test appears as a separate cargo test
- **marlin**: Verilator integration for RTL simulation
- **xshell**: Spike execution and output parsing
- **Dynamic discovery**: Automatically finds all `.vh` files in `tests/`

Architecture:
```
build.rs (build time)
├── Generate Verilog from Chisel
├── Clone riscv-tests repository
├── Build rv32ui test suite
└── Convert ELF → hex files

integration.rs (test time)
├── Discover tests from manifest
├── For each test:
│   ├── Load hex into Verilator
│   ├── Run simulation
│   ├── Capture register state
│   ├── Run same ELF in Spike
│   ├── Parse Spike register state
│   └── Compare and report differences
```

## Key Features

✅ **Generate once, test many**: Verilog generation is decoupled from program loading
✅ **Fast iteration**: No need to regenerate Verilog for each test program
✅ **Debug visibility**: PC and register write traces for debugging
✅ **UART support**: Can test programs that use UART I/O
✅ **Configurable sizes**: ROM and RAM sizes can be adjusted

## Adding New Top Modules

To test different CPU configurations (e.g., with different cache sizes, pipeline depths):

1. **Create new Verilog binding in `src/lib.rs`**:
   ```rust
   #[verilog(src = "path/to/CustomTop.sv", name = "CustomTop")]
   pub struct CustomTop;
   ```

2. **Update test discovery in `tests/integration.rs`**:
   ```rust
   let top_modules = vec![
       TopModule { name: "VerilatorTop" },
       TopModule { name: "CustomTop" },
   ];
   ```

3. **Add runner function**:
   ```rust
   fn run_verilator_test(top: &TopModule, hex_path: &Path) -> Result<TestResult> {
       match top.name {
           "VerilatorTop" => run_verilator_top_test(hex_path),
           "CustomTop" => run_custom_top_test(hex_path),
           _ => anyhow::bail!("Unknown top module: {}", top.name),
       }
   }
   ```

Now `cargo test --test integration` will run all 42 tests against each Top module configuration!

## Future Improvements

- [ ] Implement proper RISC-V test completion detection via `tohost` protocol
- [ ] Add support for rv32im (multiply/divide) and rv32ic (compressed) tests
- [ ] Add waveform dumping (VCD/FST) for failed tests
- [ ] Optimize by reusing Verilator runtime across tests
- [ ] Add memory state comparison in addition to registers
- [ ] Add cycle count and performance metrics comparison
